
# План миграции бэкенда на Python (Flask) для проекта ProDvor

Этот документ содержит полный план и серию промптов для создания Python-бэкенда, который будет полностью совместим с существующим фронтендом ProDvor.

**Стратегия:** Мы будем использовать фреймворк Flask с SQLAlchemy для работы с базой данных PostgreSQL. Каждый промпт ниже представляет собой законченный шаг, который можно последовательно отправлять AI-ассистенту в новом проекте Firebase Studio, созданном на основе шаблона "Python (Flask)".

---

## Шаг 1: Настройка проекта и создание всех моделей данных

**Промпт 1:**

"Привет! Давай создадим основу нашего Flask-приложения для работы с PostgreSQL. Нам нужно:
1.  Убедиться, что в `requirements.txt` добавлены `Flask-SQLAlchemy`, `psycopg2-binary` и `Flask-Cors`.
2.  Инициализировать Flask-приложение.
3.  Настроить SQLAlchemy для работы с базой данных PostgreSQL. Используй стандартную строку подключения, например: `postgresql://user:password@host:port/database`. Не забудь также инициализировать `CORS`.
4.  Создать модели данных (SQLAlchemy models) для всех сущностей проекта.

Вот структура моделей:

-   **User**:
    -   `id`: `Integer`, первичный ключ
    -   `nickname`: `String(80)`, уникальный, не может быть null
    -   `email`: `String(120)`, уникальный, не может быть null
    -   `avatarUrl`: `String(200)`
    -   `role`: `String(50)`, не может быть null
    -   `city`: `String(100)`
    -   `elo`: `Integer`, по умолчанию `1200`
    -   Отношение к `PlayerProfile`, `RefereeProfile`, `CoachProfile`, `Post`.

-   **Team**:
    -   `id`: `Integer`, первичный ключ
    -   `name`: `String(120)`, не может быть null
    -   `logoUrl`: `String(200)`
    -   `captainId`: `Integer`, внешний ключ к `user.id`
    -   `game`: `String(100)`
    -   `rank`: `Integer`, по умолчанию `1200`
    -   `city`: `String(100)`
    -   `wins`: `Integer`, по умолчанию `0`
    -   `losses`: `Integer`, по умолчанию `0`
    -   `leagueRank`: `String(50)`
    -   `currentStreakType`: `String(1)` (W или L)
    -   `currentStreakCount`: `Integer`
    -   `form`: `String(5)` (например, 'WWLWD')
    -   `mvpPlayerId`: `Integer`, внешний ключ к `user.id` (может быть null)
    -   `topScorerPlayerId`: `Integer`, внешний ключ к `user.id` (может быть null)
    -   `cleanSheets`: `Integer`, по умолчанию `0`
    -   `avgRating`: `Integer`, по умолчанию `0`
    -   `createdAt`: `DateTime`, по умолчанию `func.now()`
    -   Отношение к `Post`.

-   **PlayerProfile**:
    -   `id`: `Integer`, первичный ключ
    -   `userId`: `Integer`, внешний ключ к `user.id`, уникальный
    -   `elo`: `Integer`, по умолчанию `1000`
    -   `matchesPlayed`: `Integer`, по умолчанию `0`
    -   `wins`: `Integer`, по умолчанию `0`

-   **RefereeProfile**:
    -   `id`: `Integer`, первичный ключ
    -   `userId`: `Integer`, внешний ключ к `user.id`, уникальный
    -   `category`: `String(50)`
    -   `matchesJudged`: `Integer`, по умолчанию `0`

-   **CoachProfile**:
    -   `id`: `Integer`, первичный ключ
    -   `userId`: `Integer`, внешний ключ к `user.id`, уникальный
    -   `specialization`: `String(150)`
    -   `experienceYears`: `Integer`
    
-   **Tournament**:
    -   `id`: `Integer`, первичный ключ
    -   `name`: `String(150)`, не может быть null
    -   `game`: `String(100)`
    -   `status`: `String(50)`
    -   `prizePool`: `String(100)`
    -   `participants`: `Integer`, по умолчанию `0`
    -   `maxParticipants`: `Integer`
    -   `startDate`: `String(100)`
    
-   **Post**:
    -   `id`: `Integer`, первичный ключ
    -   `authorId`: `Integer`, внешний ключ к `user.id`
    -   `teamId`: `Integer`, внешний ключ к `team.id` (может быть null)
    -   `content`: `Text`
    -   `timestamp`: `DateTime`, по умолчанию `func.now()`
    -   Отношение к `Comment`.

-   **Comment**:
    -   `id`: `Integer`, первичный ключ
    -   `postId`: `Integer`, внешний ключ к `post.id`
    -   `authorId`: `Integer`, внешний ключ к `user.id`
    -   `text`: `Text`
    -   `timestamp`: `DateTime`, по умолчанию `func.now()`

-   **Playground**:
    -   `id`: `Integer`, первичный ключ
    -   `name`: `String(150)`
    -   `address`: `String(250)`
    -   `type`: `String(100)`
    -   `surface`: `String(100)`
    
-   **Quest**:
    -   `id`: `Integer`, первичный ключ
    -   `name`: `String(150)`
    -   `description`: `Text`
    -   `type`: `String(50)`
    -   `xp_reward`: `Integer`
    
-   **Achievement**:
    -   `id`: `Integer`, первичный ключ
    -   `name`: `String(150)`
    -   `description`: `Text`
    -   `icon`: `String(50)`

-   **Sponsor**:
    -   `id`: `Integer`, первичный ключ
    -   `name`: `String(150)`
    -   `logoUrl`: `String(200)`
    -   `contribution`: `String(200)`

-   **TeamMembers** (связующая таблица для User и Team):
    -   `userId`: `Integer`, внешний ключ к `user.id`, первичный ключ
    -   `teamId`: `Integer`, внешний ключ к `team.id`, первичный ключ

-   **TeamApplications** (новая таблица для заявок в команду):
    -   `userId`: `Integer`, внешний ключ к `user.id`, первичный ключ
    -   `teamId`: `Integer`, внешний ключ к `team.id`, первичный ключ
    -   `status`: `String(20)`, по умолчанию `'pending'` ('pending', 'accepted', 'declined')
    -   `createdAt`: `DateTime`, по умолчанию `func.now()`

-   **TeamFollowers** (связующая таблица для подписок на команды):
    -   `userId`: `Integer`, внешний ключ к `user.id`, первичный ключ
    -   `teamId`: `Integer`, внешний ключ к `team.id`, первичный ключ

-   **TeamSeasonStats** (новая таблица для статистики по сезонам):
    -   `id`: `Integer`, первичный ключ
    -   `teamId`: `Integer`, внешний ключ к `team.id`
    -   `season`: `Integer` (год, например 2025)
    -   `leagueRank`: `String(50)`
    -   `finalElo`: `Integer`
    -   `wins`: `Integer`
    -   `losses`: `Integer`

Пожалуйста, создай файл `app.py` со всем этим кодом и инициализируй базу данных."

---

## Шаг 2: Создание API для Пользователей (Users)

**Промпт 2:**

"Отлично! Теперь давай создадим API для работы с пользователями в файле `app.py`. Нам нужны следующие эндпоинты:

1.  **`GET /api/v1/users`**:
    -   Должен возвращать список всех пользователей.
    -   Каждый объект в списке должен содержать все поля из модели `User`.

2.  **`GET /api/v1/users/<int:user_id>`**:
    -   Должен находить пользователя по `user_id` и возвращать его данные.
    -   Если пользователь не найден, возвращать ошибку 404.

3.  **`POST /api/v1/users`**:
    -   Должен создавать нового пользователя.
    -   Принимает JSON с полями: `nickname`, `email`, `role`, `city`.
    -   Должен проверять, что `nickname` и `email` уникальны. Если нет, возвращать ошибку 400.
    -   **Важно:** После создания `User`, в зависимости от значения поля `role`, должен создаваться соответствующий профиль (`PlayerProfile`, `RefereeProfile` или `CoachProfile`) с привязкой по `userId`.
    -   Возвращает созданный объект пользователя со статусом 201."

---

## Шаг 3: Создание API для Команд (Teams)

**Промпт 3:**

"Продолжаем. Теперь нам нужен API для команд в `app.py`. Реализуй следующие эндпоинты:

1.  **`GET /api/v1/teams`**:
    -   Должен возвращать список всех команд.
    -   Каждая команда в списке должна содержать все поля из модели `Team`.

2.  **`GET /api/v1/teams/<int:team_id>`**:
    -   Должен находить команду по `team_id` и возвращать её полные данные, **включая список ID участников** (`members`), полученный из таблицы `TeamMembers`.
    -   Если команда не найдена, возвращать ошибку 404.

3.  **`POST /api/v1/teams`**:
    -   Должен создавать новую команду.
    -   **Логика:**
        -   Принимает JSON с полями: `name`, `captainId`, `game`, `city`.
        -   **Важно:** Пользователь с `captainId` автоматически становится членом команды (добавляется в таблицу `TeamMembers`).
        -   Для новой команды должен автоматически генерироваться `logoUrl` с использованием сервиса плейсхолдеров, например, `https://placehold.co/512x512.png`.
    -   Возвращает созданный объект команды со статусом 201."

---

## Шаг 4: API для заявок в команду

**Промпт 4:**

"Отлично! Теперь нам нужен полный набор эндпоинтов для управления заявками на вступление в команду.

1.  **`POST /api/v1/teams/<int:team_id>/apply`**
    -   **Описание:** Подать заявку на вступление в команду.
    -   **Защита:** Требует аутентификации (`@jwt_required()`). ID пользователя берется из токена.
    -   **Логика:**
        -   Проверить, что пользователь еще не в команде и не подавал заявку.
        -   Проверить, соответствует ли основная дисциплина пользователя дисциплине команды. Если нет, вернуть ошибку 403 с сообщением `User does not have the required sport`.
        -   Создать новую запись в таблице `TeamApplications` со статусом `pending`.
    -   **Ответ:** `{"success": true, "message": "Заявка успешно отправлена"}`.

2.  **`GET /api/v1/teams/<int:team_id>/applications`**
    -   **Описание:** Получить список всех заявок на вступление в команду.
    -   **Защита:** Требует аутентификации. Доступен **только капитану команды**.
    -   **Логика:** Найти все записи в `TeamApplications` для данной `team_id` со статусом `pending` и вернуть полные объекты пользователей, которые их подали.
    -   **Ответ:** Массив объектов `User`.

3.  **`POST /api/v1/teams/<int:team_id>/applications/<int:user_id>/respond`**
    -   **Описание:** Принять или отклонить заявку.
    -   **Защита:** Требует аутентификации. Доступен **только капитану команды**.
    -   **Тело запроса (JSON):** `{"action": "accept"}` или `{"action": "decline"}`.
    -   **Логика:**
        -   Найти заявку в `TeamApplications`.
        -   Если `action` == `accept`:
            -   Добавить пользователя в таблицу `TeamMembers`.
            -   Удалить запись из `TeamApplications`.
        -   Если `action` == `decline`:
            -   Удалить запись из `TeamApplications`.
    -   **Ответ:** `{"success": true, "message": "Решение принято"}`."


---

## Шаг 5: API для статистики команды

**Промпт 5:**

"Отлично. Теперь создай новый эндпоинт для получения сезонной статистики команды.

-   **`GET /api/v1/teams/<int:team_id>/stats`**
    -   Должен возвращать историю статистики для команды с `team_id`.
    -   Данные нужно брать из таблицы `TeamSeasonStats`.
    -   Результат должен быть массивом объектов, где каждый объект представляет один сезон:
        ```json
        [
          {
            "season": 2025,
            "leagueRank": "1-е место",
            "finalElo": 1650,
            "wins": 15,
            "losses": 3
          },
          {
            "season": 2024,
            "leagueRank": "Топ-8",
            "finalElo": 1480,
            "wins": 12,
            "losses": 8
          }
        ]
        ```
    -   Если для команды нет статистики, эндпоинт должен возвращать пустой массив `[]`."

---

## Шаг 6: Создание API для Турниров (Tournaments)

**Промпт 6:**

"Реализуй API для турниров в том же файле `app.py`.

1.  **`GET /api/v1/tournaments`**:
    -   Должен возвращать список всех турниров со всеми полями.

2.  **`GET /api/v1/tournaments/<int:tournament_id>`**:
    -   Должен находить турнир по `tournament_id` и возвращать его полные данные.
    -   Если турнир не найден, возвращать ошибку 404.

3.  **`POST /api/v1/tournaments`**:
    -   Должен создавать новый турнир.
    -   Принимает JSON с полями: `name`, `game`, `status`, `maxParticipants`, `startDate`.
    -   Возвращает созданный объект турнира со статусом 201."

---

## Шаг 7: Создание API для Постов и Комментариев

**Промпт 7:**

"Давай добавим эндпоинты для социальной ленты.

1.  **`GET /api/v1/posts`**:
    -   Должен возвращать список всех постов.

2.  **`POST /api/v1/posts`**:
    -   Создает новый пост. Принимает JSON: `authorId`, `content`, `teamId` (опционально).
    -   Возвращает созданный пост со статусом 201.

3.  **`GET /api/v1/posts/<int:post_id>/comments`**:
    -   Возвращает все комментарии для конкретного поста.

4.  **`POST /api/v1/posts/<int:post_id>/comments`**:
    -   Добавляет новый комментарий к посту. Принимает JSON: `authorId`, `text`.
    -   Возвращает созданный комментарий со статусом 201."

---

## Шаг 8: Создание API для остальных сущностей

**Промпт 8:**

"Почти готово. Давай добавим эндпоинты для создания и получения данных для оставшихся сущностей. Добавь в `app.py`:

1.  **`GET /api/v1/playgrounds`**: Возвращает список всех площадок.
2.  **`POST /api/v1/playgrounds`**: Создает новую площадку. Принимает JSON: `name`, `address`, `type`, `surface`.

3.  **`GET /api/v1/quests`**: Возвращает список всех квестов.

4.  **`GET /api/v1/achievements`**: Возвращает список всех достижений.

5.  **`GET /api/v1/sponsors`**: Возвращает список всех спонсоров.
6.  **`POST /api/v1/sponsors`**: Создает нового спонсора. Принимает JSON: `name`, `logoUrl`, `contribution`.

7.  **`GET /api/v1/profiles/player`**: Возвращает список всех профилей игроков (`PlayerProfile`).
8.  **`GET /api/v1/profiles/referee`**: Возвращает список всех профилей судей (`RefereeProfile`).
9.  **`GET /api/v1/profiles/coach`**: Возвращает список всех профилей тренеров (`CoachProfile`).
"

---

## Шаг 9: Обновление данных пользователя (включая дисциплины)

**Промпт 9:**

"Отлично. Теперь нам нужен эндпоинт для обновления данных пользователя. Это критически важно для настроек профиля.

1.  **`PUT /api/v1/users/<int:user_id>`**:
    -   Должен обновлять данные пользователя по `user_id`.
    -   **Важно:** Этот эндпоинт должен уметь обрабатывать частичные обновления. Например, фронтенд может прислать только поле `bio`, или только поле `sports`.
    -   **Обработка дисциплин:** Если в теле запроса приходит поле `sports` (это будет массив строковых ID, например: `{"sports": ["sport-1", "sport-2"]}`), бэкенд должен **полностью перезаписать** все текущие связи пользователя с дисциплинами на новые. Если приходит пустой массив `[]`, все дисциплины должны быть удалены.
    -   В случае успеха, эндпоинт должен возвращать полный обновленный объект пользователя со статусом 200.
"

---

После выполнения этих шагов у вас будет готов базовый Python-бэкенд, полностью соответствующий потребностям текущего фронтенда. Вы сможете заменить моковые данные в файлах фронтенда на реальные вызовы к этим API.
    
    
