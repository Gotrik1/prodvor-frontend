# Интеграция API: Как фронтенд и бэкенд синхронизируют документацию

Этот документ описывает автоматизированный процесс, с помощью которого наш Next.js фронтенд получает актуальную спецификацию API (файл `openapi.json`) от Python-бэкенда.

## 1. Концепция: Единый источник правды

- **Источник правды** — это всегда **бэкенд**. Python-сервер генерирует и отдает файл `openapi.json`, который является точным и актуальным описанием всех его эндпоинтов.
- **Фронтенд** является **потребителем** этой спецификации. Он не редактирует `openapi.json` вручную, а только скачивает его.
- **Цель** — автоматизировать обновление локальной копии `openapi.json` на фронтенде, чтобы разработчик мог в любой момент перегенерировать типобезопасный API-клиент (SDK).

## 2. Как это работает: Пошаговый процесс

Процесс состоит из трех основных частей: настройка на бэкенде, служебный API-маршрут на фронтенде и автоматический запуск по расписанию.

### Шаг 1: Задача для Бэкенда

Бэкенд должен предоставлять статический эндпоинт, по которому можно скачать актуальный `openapi.json`.

- **Эндпоинт:** Должен быть доступен по GET-запросу. Например: `https://<ваш_домен_бэкенда>/openapi.json`.
- **Путь к этому эндпоинту** настраивается в файле `.env` фронтенда через переменную `BACKEND_OPENAPI_PATH`.

### Шаг 2: Служебный API-маршрут на Фронтенде

На фронтенде существует специальный API-маршрут, который выполняет всю работу по обновлению.

- **Файл:** `src/app/api/v1/cron/update-openapi/route.ts`
- **Адрес:** `/api/v1/cron/update-openapi`
- **Что он делает:**
    1.  Получает GET-запрос.
    2.  Читает переменные `NEXT_PUBLIC_API_BASE_URL` и `BACKEND_OPENAPI_PATH` из `.env`, чтобы сформировать полный URL к файлу на бэкенде.
    3.  Отправляет `fetch`-запрос на этот URL.
    4.  Если ответ успешен, он берет полученный JSON, форматирует его и **перезаписывает** локальный файл `src/docs/openapi.json`.
    5.  Если произошла ошибка (бэкенд недоступен, неверный URL), он выводит подробную ошибку в консоль.
- **Исключение в Middleware:** Путь `/api/v1/cron/.*` добавлен в исключения в файле `middleware.ts`, чтобы этот служебный маршрут никогда не блокировался логикой аутентификации.

### Шаг 3: Автоматический запуск (Cron Job)

Этот процесс должен запускаться автоматически по расписанию.

- **Механизм:** Используется внешний сервис (например, GitHub Actions `schedule`, Vercel Cron Jobs или обычный `cron` на сервере).
- **Задача:** Этот сервис должен всего лишь раз в определенный период (например, раз в день) отправлять GET-запрос на адрес:
  `https://<ваш_домен_фронтенда>/api/v1/cron/update-openapi`
- **Ручной запуск:** Для немедленного обновления можно просто перейти по этому URL в браузере или выполнить `curl` в терминале.

## 3. Процесс для разработчика

1.  **Бэкенд-разработчик** вносит изменения в API своего Python-приложения.
2.  **Бэкенд** автоматически пересобирает свой `openapi.json`.
3.  **Cron Job** по расписанию (или разработчик вручную) "дергает" эндпоинт `/api/v1/cron/update-openapi` на фронтенде.
4.  **Фронтенд** скачивает новый `openapi.json` с бэкенда.
5.  **Фронтенд-разработчик** видит изменения в `src/docs/openapi.json` и запускает команду для перегенерации API-клиента:
    ```bash
    npx openapi-generator-cli generate -i src/docs/openapi.json -g typescript-axios -o src/shared/api
    ```
6.  **Готово!** Теперь во всем фронтенд-коде доступны новые типы и методы API.

Этот подход гарантирует, что фронтенд и бэкенд всегда "говорят на одном языке", и минимизирует ошибки, связанные с рассинхронизацией API.