
export const USER_PROFILE_ARCH = `
# Архитектура данных профиля пользователя ProDvor

Этот документ описывает предлагаемую архитектуру для агрегации данных на странице профиля пользователя, аналогично подходу ВКонтакте и других крупных социальных платформ.

## 1. Основной принцип: Backend-Side Aggregation

**Проблема:** Страница профиля пользователя должна отображать огромное количество разнородной информации: личные данные, статистику, список команд, посты, друзей, достижения и т.д. Попытка загрузить все это с помощью множества отдельных запросов с фронтенда приведет к медленной загрузке ("эффект водопада") и усложнению клиентского кода.

**Решение:** Бэкенд должен предоставлять один или несколько комплексных эндпоинтов (например, \`/users/:id\`), которые сами собирают ("агрегируют") всю необходимую информацию из разных таблиц и микросервисов и отдают ее фронтенду в удобном, структурированном виде.

Фронтенд делает **один основной запрос** для получения 80% данных для первого экрана, а остальную информацию (например, бесконечную ленту постов) подгружает по мере необходимости.

## 2. Декомпозиция данных профиля

Разделим страницу профиля на логические блоки (виджеты) и определим, откуда бэкенд должен брать для них данные.

| Виджет / Блок данных             | Источник на бэкенде (таблица/сущность)                 | Как получается фронтендом                                                                                           |
| -------------------------------- | ------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------- |
| **Основная информация**          | \`users\`                                              | Часть основного ответа \`/users/:id\`. Содержит: \`id\`, \`firstName\`, \`lastName\`, \`nickname\`, \`avatarUrl\`, \`bio\` и т.д. |
| **Команды пользователя**         | \`teams\`, \`team_members\` (связующая)                 | Часть основного ответа (при \`?include_teams=true\`). Бэкенд делает JOIN для получения списка команд.             |
| **Статистика игрока**            | \`player_profiles\`                                    | Часть основного ответа. Бэкенд делает JOIN с таблицей \`player_profiles\` по \`userId\`.                               |
| **Прогресс и достижения**        | \`user_progress\`                                      | Часть основного ответа. Бэкенд делает JOIN с таблицей \`user_progress\` по \`userId\`.                                |
| **Социальные связи**             | \`friends\`, \`followers\` (связующие таблицы)        | Часть основного ответа. Бэкенд возвращает количество друзей/подписчиков. Сами списки могут подгружаться отдельно. |
| **Публикации (лента)**           | \`posts\`                                              | **Отдельный эндпоинт** с пагинацией: \`GET /users/:id/posts?page=1&limit=10\`.                                          |
| **Медиа (фото/видео)**           | \`media_files\`                                        | **Отдельный эндпоинт** с пагинацией: \`GET /users/:id/media?type=photo&page=1&limit=12\`.                             |
| **Тренировочная активность**     | \`training_sessions\`, \`training_plans\`            | **Агрегированные данные** как часть основного ответа: общая статистика (частота, специализация).                  |

## 3. План реализации на стороне бэкенда

### Шаг 1: Обновить структуру базы данных

Убедиться, что существуют все необходимые таблицы и связи между ними:

-   \`users\` (основная информация)
-   \`teams\`
-   \`team_members\` (связь многие-ко-многим между \`users\` и \`teams\`)
-   \`player_profiles\` (связь один-к-одному с \`users\`)
-   \`user_progress\` (связь один-к-одному с \`users\`)
-   \`friends\` (связующая таблица для \`users\` - \`users\`)
-   \`posts\` (с внешним ключом на \`authorId\`)

### Шаг 2: Реализовать логику агрегации в эндпоинте

Эндпоинт \`GET /api/v1/users/:id\` (и его аналог \`/users/me\`) должен выполнять следующую логику:

1.  Найти пользователя в таблице \`users\` по \`id\`.
2.  Найти связанный профиль в \`player_profiles\`.
3.  Найти связанный прогресс в \`user_progress\`.
4.  Если есть параметр \`?include_teams=true\`, найти все ID команд для этого пользователя в \`team_members\`, а затем получить полные объекты этих команд из \`teams\`.
5.  Собрать все найденные данные в один JSON-объект.
6.  Отдать этот объект фронтенду.

### Шаг 3: Создать эндпоинты с пагинацией

Создать отдельные эндпоинты для данных, которые могут быть очень большими:

-   **\`GET /api/v1/users/:id/posts\`**: Возвращает посты пользователя с пагинацией (\`limit\` и \`offset\` или \`page\`).
-   **\`GET /api/v1/users/:id/friends\`**: Возвращает друзей пользователя с пагинацией.
-   **\`GET /api/v1/users/:id/followers\`**: Возвращает подписчиков пользователя с пагинацией.

## 4. Пример "идеального" ответа от бэкенда

Этот пример показывает, как должен выглядеть ответ на основной запрос для страницы профиля. Он содержит все необходимое для первого рендера страницы.

\`\`\`json
{
  // --- Из таблицы 'users' ---
  "id": "a1b2c3d4-e5f6-7890-1234-567890abcdef",
  "firstName": "Иван",
  "lastName": "Иванов",
  "nickname": "IvanTheGreat",
  "avatarUrl": "https://...",
  "coverImageUrl": "https://...",
  "role": "Игрок",
  "city": "Москва",
  "bio": "Люблю футбол и свою команду!",
  "elo": 1550, // Может быть здесь для быстрого доступа или в player_profile
  
  // --- Из таблицы 'player_profiles' (JOIN по userId) ---
  "player_profile": {
    "matchesPlayed": 120,
    "wins": 79,
    "goals": 76,
    "assists": 37,
    "mvpAwards": 30
  },

  // --- Из таблицы 'user_progress' (JOIN по userId) ---
  "progress": {
    "points": 8500,
    "level": 9,
    "unlockedAchievements": ["ach-fb-1", "ach-fb-2"]
  },

  // --- Из таблиц 'team_members' и 'teams' (JOIN по userId, если ?include_teams=true) ---
  "teams": [
    {
      "id": "team-uuid-1",
      "name": "Ночные Снайперы",
      "logoUrl": "https://...",
      "rank": 1600
    }
  ],

  // --- Агрегированные счетчики из таблиц 'friends' и 'followers' ---
  "counters": {
      "friends": 54,
      "followers": 128,
      "posts": 42
  }
}
\`\`\`

Этот подход обеспечивает быстрый первый рендер страницы и позволяет подгружать "тяжелые" данные (ленту постов, список друзей) по мере необходимости, создавая плавный и отзывчивый пользовательский опыт.
`;

    